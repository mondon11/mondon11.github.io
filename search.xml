<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[利用python requests帮你评教（国科大教务系统）]]></title>
    <url>%2F2017%2F08%2F29%2F%E5%88%A9%E7%94%A8python%20requests%E5%B8%AE%E4%BD%A0%E8%AF%84%E6%95%99%EF%BC%88%E5%9B%BD%E7%A7%91%E5%A4%A7%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Talk is cheap, show me the code. -Linus Torvalds 在国科大，如果你错过了评教，就看不到该课程的成绩，是不是很烦。我这里提供一个方法，即使你错过了评教时间，也能评教然后看到成绩。主要利用python的requests库，python2 和 python3 都测试成功。直接上代码吧! 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#coding=utf-8import requestsimport reimport jsonimport randomimport numpy as np#创建session，传递cookieconn=requests.session()#登录print ('登录中...')url='http://onestop.ucas.ac.cn/Ajax/Login/0'data=&#123; 'username':'xxx@xxx', #你的登录邮箱 'password':'xxxxxx', #你的密码 'remember':'checked'&#125;headers=&#123; 'Accept':'*/*', 'Accept-Encoding':'gzip, deflate', 'Accept-Language':'zh-CN,zh;q=0.8', 'Connection':'keep-alive', 'Content-Length':'64', 'Content-Type':'application/x-www-form-urlencoded; charset=UTF-8', 'Host':'onestop.ucas.ac.cn', 'rigin':'http://onestop.ucas.ac.cn', 'Referer':'http://onestop.ucas.ac.cn/home/index', 'User-Agent':'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36', 'X-Requested-With':'XMLHttpRequest'&#125;resp=conn.post(url=url,headers=headers,data=data)print ('登陆完成！')#进入选课系统print ('进入评教系统...')url=json.loads(resp.text)['msg']resp=conn.get(url=url)url='http://sep.ucas.ac.cn/portal/site/226/821'resp=conn.get(url=url)reg=r'window.location.href=\'(.+?)\''url_reg=re.compile(reg)url_list=url_reg.findall(resp.text)url=url_list[0]resp=conn.get(url=url) #访问重定向的网址 进入选课系统#进入选择课程界面 获得query_string_parasurl='http://jwxk.ucas.ac.cn/courseManage/main'resp=conn.get(url=url)reg=r'\"?s=(.+?)\";'url_reg=re.compile(reg)query_list=url_reg.findall(resp.text)query_string_paras=query_list[0]#获取所选课程id号url='http://jwxk.ucas.ac.cn/courseManage/selectedCourse'resp=conn.get(url=url)reg=r'courseplan/+(.+?)\"'course_reg=re.compile(reg)course_list=course_reg.findall(resp.text)#评教print ('评教中,请耐心等待...')comment=&#123; '1':'老师认真负责，作业布置的也十分合理，一学期下来收获很多', '2':'老师讲的好，同学们听得都很认真，作业量也适中，希望老师继续保持下去', '3':'老师的课讲得好，作业布置的合理，好好学能有很大收获' &#125;data=&#123;str(x):'900' for x in np.arange(900)&#125;data_other=&#123; #5星 和 评价 'starFlag':'5', 'flaw':'', 'suggest':''&#125;data.update(data_other)for course in course_list: url='http://jwxk.ucas.ac.cn/evaluate/save/'+course+'?s='+query_string_paras data_merit=&#123;'merit':comment[random.choice(['1','2','3'])]&#125; data_new=data.copy() data_new.update(data_merit) resp=conn.post(url=url,data=data_new)print ('评教完成！') 本程序仅供学习使用，如对教务系统造成影响，我会撤稿。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>requests</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Flask为对答机器人写个RESTful API]]></title>
    <url>%2F2017%2F08%2F22%2F%E4%BD%BF%E7%94%A8Flask%E4%B8%BA%E5%AF%B9%E7%AD%94%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%86%99%E4%B8%AARESTful%20API%20%2F</url>
    <content type="text"><![CDATA[During his own Google interview, Jeff Dean was asked the implications if P=NP were true. He said, “P = 0 or N = 1.” Then, before the interviewer had even finished laughing, Jeff examined Google’s public certificate and wrote the private key on the whiteboard. LOL 上一篇文章讲了基于Tensorflow seq2seq 的对答机器人在阿里云上的部署（Flask+Nginx+Gunicorn），这里打算动手写个简单的RESTful API ，方便大家调用。因为我是个刚入门web开发的新手，所以这篇文章算是一个对实践的小小总结吧。 RESTful API 简介这里有个关于RESTful API的通俗易懂的解释，写的很好，我就简单引用其中一段话吧： 大家都知道”古代”网页是前端后端融在一起的，比如之前的PHP，JSP等。在之前的桌面时代问题不大，但是近年来移动互联网的发展，各种类型的Client层出不穷，RESTful可以通过一套统一的接口为 Web，iOS和Android提供服务。另外对于广大平台来说，比如Facebook platform，微博开放平台，微信公共平台等，它们不需要有显式的前端，只需要一套提供服务的接口，于是RESTful更是它们最好的选择。 -覃超 Flask实现RESTful API首先来说下HTTP的几种请求方式： HTTP定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。 -hyddd POST请求方式我之前写过简单的爬虫程序，发现POST和GET是两种最常用的请求方式。我们先动手实践下POST请求方式，完成”客户端发送什么，服务器端就返回什么”这样一个任务，然后在客户端打印出结果验证下：创建client.py：123456789#coding=utf-8#clent.pyimport requestsimport jsonurl = 'http://127.0.0.1:5000/api'data=&#123;'msg':'hello'&#125;req = requests.post(url=url,data=data) print (req.content) 创建server.py：12345678910111213141516171819202122#coding=utf-8#server.pyfrom flask import Flask, requestimport jsonapp = Flask(__name__)app.debug = True@app.route('/api', methods=['POST'])def api(): if request.method == 'POST': dict_data=request.form #type:ImmutableMultiDict return dict_data['msg'] else: return 'not POST'@app.route('/')def index(): return 'hello world!'if __name__ == '__main__': app.run(host='127.0.0.1', port=5000) 运行server.py，然后运行client.py，会输出’hello’，交互成功！我们也可以添加报头，服务端根据报头中的Content-Type字段来获知请求中的消息主体是用何种方式进行编码，再对消息主体进行解析。我们将上面的代码稍作改动，添加Content-Type为application/x-www-form-urlencoded的报头，以form表单提交数据：创建client.py：12345678910#coding=utf-8#clent.pyimport requestsimport jsonurl = 'http://127.0.0.1:5000/api'data=&#123;'msg':'hello'&#125;headers=&#123;'Content-Type':'application/x-www-form-urlencoded'&#125;req = requests.post(url=url,headers=headers,data=data)print (req.content) server.py不变运行server.py，然后运行client.py，会输出’hello’，交互成功！实际上，第一个例子中，报头会自动添加application/x-www-form-urlencoded的Content-Type，所以这里server.py不变没有问题。当然，我们还可以以json字符串形式提交数据，添加Content-Type为application/json的报头：创建client.py12345678910#coding=utf-8#clent.pyimport requestsimport jsonurl = 'http://127.0.0.1:5000/api'data=json.dumps(&#123;'msg':'hello'&#125;)headers=&#123;'Content-Type':'application/json'&#125;req = requests.post(url=url,headers=headers,data=data)print (req.content) 创建server.py12345678910111213141516171819202122#coding=utf-8#server.pyfrom flask import Flask, requestimport jsonapp = Flask(__name__)app.debug = True@app.route('/api', methods=['POST'])def api(): if request.method == 'POST': dict_data=request.get_json() #dict return dict_data['msg'] else: return 'not POST'@app.route('/')def index(): return 'hello world!'if __name__ == '__main__': app.run(host='127.0.0.1', port=5000) 运行server.py，然后运行client.py，会输出’hello’，交互成功！但是如果我们去掉Content-Type为application/json的报头：创建client.py：123456789#coding=utf-8#clent.pyimport requestsimport jsonurl = 'http://127.0.0.1:5000/api'data=json.dumps(&#123;'msg':'hello'&#125;)req = requests.post(url=url,data=data)print (req.content) server.py不变。运行server.py，然后运行client.py，server端会报错！！！原来报头不会自动添加application/json的Content-Type，服务器端不能将请求数据解析为json，所以此时request对象的json属性为None，用get_json()方法自然就不行了。别慌，我们对server.py做如下改动即可：创建server.py:1234567891011121314151617181920212223#coding=utf-8#server.pyfrom flask import Flask, requestimport jsonapp = Flask(__name__)app.debug = True@app.route('/api', methods=['POST'])def api(): if request.method == 'POST': str_data=request.get_data() #str dict_data=json.loads(str_data) #dict return dict_data['msg'] else: return 'not POST'@app.route('/')def index(): return 'hello world!'if __name__ == '__main__': app.run(host='127.0.0.1', port=5000) 运行server.py，然后运行client.py，会输出’hello’，交互成功！ GET请求方式我们再来实践下GET请求：创建client.py：123456789#coding=utf-8#clent.pyimport requestsimport jsonurl = 'http://127.0.0.1:5000/api'data=&#123;'msg':'hello'&#125;req = requests.get(url=url,params=data)print (req.content) 创建server.py：12345678910111213141516171819202122#coding=utf-8#server.pyfrom flask import Flask, requestimport jsonapp = Flask(__name__)app.debug = True@app.route('/api', methods=['GET'])def api(): if request.method == 'GET': dict_data=request.args #type=ImmutableMultiDict return dict_data['msg'] else: return 'not GET'@app.route('/')def index(): return 'hello world!'if __name__ == '__main__': app.run(host='127.0.0.1', port=5000) 运行server.py，然后运行client.py，会输出’hello’，交互成功！其实，我们在client.py加入1print (req.url) 看到输出的url为http://127.0.0.1:5000/api?msg=hello ，也就是说，GET请求的数据会附在url之后（就是把数据放置在HTTP协议头中），以?分割url和传输数据，并且参数之间以&amp;相连。我们在本地浏览器访问http://127.0.0.1:5000/api?msg=nice ，就可以看到网页显示’nice’。这里有Flask API的说明，可以看下”进入的请求对象”这一部分了解下request的属性和方法。 状态码和错误处理最后再来讲下状态码和错误处理，这也是很重要的。我们比较熟悉的状态码有200-OK，400-Bad Request，404-Not Found，500 Internal Server Error等。正常情况下，用户将得到正确的结果，此时HTTP状态为200-OK ，但如果用户调用API的方式不当，服务器将会返回对应的错误，用户就可以根据状态码来判断错误类型进而调整调用方法。但是，默认的错误信息比较笼统，比如返回400-Bad Request时，到底请求哪里出了问题，用户也很难判断。我们在使用Flask设计RESTful API时，可以使用@error_handler修饰器覆盖默认的Flask错误处理，自定义错误信息的描述，方便用户修改错误。举个例子：我们创建server.py：1234567891011121314151617181920212223242526272829303132#coding=utf-8#server.pyfrom flask import Flask, request,jsonifyimport jsonapp = Flask(__name__)app.debug = True@app.route('/api', methods=['GET'])def api(): if request.method == 'GET': dict_data=request.args #ImmutableMultiDict return dict_data['msg'] else: return bad_method()@app.errorhandler(405)def bad_method(error=None): message=&#123; 'status':405, 'message':'HTTP method only allows GET' &#125; resp=jsonify(message) resp.status_code=405 return resp@app.route('/')def index(): return 'hello world!'if __name__ == '__main__': app.run(host='127.0.0.1', port=5000) 创建client.py：123456789#coding=utf-8#clent.pyimport requestsimport jsonurl = 'http://127.0.0.1:5000/api'data=&#123;'msg':'hello'&#125;req = requests.post(url=url,data=data) print (req.content) 运行server.py，然后运行client.py，会输出：1234&#123; "message": "HTTP method only allows GET", "status": 405&#125; 看到这样的返回信息，我想用户很清楚调用API时错在哪了吧。 对答机器人的调用示例在我的项目中，所有的API访问都是通过HTTP请求的方式。并且需要从http://101.200.59.7/api 进行访问。只支持GET和POST方式的HTTP请求。看下微信公众平台的调用效果吧：因为语料和模型还不完善，对答机器人还有些“弱智”。你可以加下面的公众号体验一下： GET方式：123456789#coding=utf-8#clent.pyimport requestsimport jsonurl='http://101.200.59.7/api'data=&#123;'msg':'吃了吗？'&#125;req = requests.get(url=url,params=data)print (req.content) POST方式：123456789#coding=utf-8#clent.pyimport requestsimport jsonurl='http://101.200.59.7/api'data=&#123;'msg':'吃了吗？'&#125;req = requests.post(url=url,data=data)print (req.content) 12345678910#coding=utf-8#clent.pyimport requestsimport jsonurl='http://101.200.59.7/api'data=&#123;'msg':'吃了吗？'&#125;headers=&#123;'Content-Type':'application/x-www-form-urlencoded'&#125;req = requests.post(url=url,headers=headers,data=data)print (req.content) 123456789#coding=utf-8#clent.pyimport requestsimport jsonurl='http://101.200.59.7/api'data=json.dumps(&#123;'msg':'吃了吗'&#125;)req = requests.post(url=url,data=data)print (req.content) 12345678910#coding=utf-8#clent.pyimport requestsimport jsonurl='http://101.200.59.7/api'data=json.dumps(&#123;'msg':'吃了吗'&#125;)headers=&#123;'Content-Type':'application/json'&#125;req = requests.post(url=url,headers=headers,data=data)print (req.content) 错误响应： HTTP状态码 错误信息 说明 400 msg must exist 数据必须以’msg’:’your data’形式传入 400 Content-Type must be application/json or application/x-www-form-urlencoded 报头只支持json和form两种形式 405 HTTP method must be GET or POST HTTP请求只支持GET和POST 其他错误请参考这里。 遇坑小记以上示例代码在python2.7环境可以成功运行。在python3环境中需要注意： POST以不加报头的json形式传输数据时，对于服务器端，python3上 request.headers没有’Content-Type’这一项，而python2上’Content-Type’为空。 python3最重要的新特性大概要算是对文本和二进制数据作了更为清晰的区分。python3 flask request.get_data()方法返回bytes，转成string需要decode(‘ascii’)。而python2 flask request.get_data()返回string。客户端打印结果req.content也有bytes和string的差别。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>RESTful</tag>
        <tag>Flask</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tensorflow + Flask + Nginx + Gunicorn 在阿里云的部署]]></title>
    <url>%2F2017%2F08%2F21%2FTensorflow%2BFlask%2BNginx%2BGunicorn%E5%9C%A8%E9%98%BF%E9%87%8C%E4%BA%91%E7%9A%84%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[生命在于折腾！ -某网友 最近在做一个基于Tensorflow seq2seq 模型的对答机器人项目。模型的训练已经在本地完成（ubuntu 16.04 + python 3.5 +Tensorflow 1.2.1），对答也可以在本地用命令行形式进行，但是我并不满足这样的一种“枯燥”的展示方式，毕竟生命在于折腾，我决定尝试下Web端展示。因为是第一次做python web开发，所以我的原则是用什么学什么。在做了简单的调研后，我决定采用下面的方式部署： vps：阿里云（学生有特惠） Web框架：Flask（简单易上手） 服务器：Gunicorn+Nginx（稳定有效） PS：本地系统是64位windows 7（另一台ubuntu主机在训练模型，卡的不行…） vps上的预准备先来看下我租用的主机的配置吧，这个是最便宜的，对于我的应用足够了。（公网IP就是我项目的地址，欢迎访问。）在开始部署之前，我建议阅读下帮助与文档，特别是对于像我一样的小白，可以少走不少弯路。首先，我们要建立本地与vps的连接，来完成本地对远程服务器的模拟。Xshell、Putty等工具都可以，我采用的是Putty，具体步骤可以参考使用 SSH 密钥对连接 Linux 实例。可是，按照步骤走下来，我们却发现连接不成功。我尝试ping了一下公网IP，居然也ping不通。原来，我们的安全组规则没有配置好。参考ECS实例安全组默认的公网规则被删除导致无法ping通： 端口范围： 建议只开放 TCP 协议的端口 22 （用于 SSH） 、3389 （用于远程桌面）和 ICMP 协议（用户 PING 探测），用于探测和远程连接。 添加这些安全组规则后，终于连接成功！1Welcome to Alibaba Cloud Elastic Compute Service ! 接下来，我们在vps上安装配置ftp服务，为后面上传项目代码做准备。具体可以参考centos 7 安装配置ftp服务。同样的问题又出现了，我们用Filezilla连接阿里云，发现连不上，原来和上面的那个问题一样，我们需要开放 TCP 协议的端口 20、21，做法和上面一样。另外，如果我们想上传文件到服务器上的某一文件夹中，我们需要修改该文件夹权限：1# chmod -R 777 [文件夹] 至此，vps上的预准备完成。 利用Anaconda安装TensorflowCentOS自带python2，因为我开发环境是python3，所以需要安装python3。并且，还要安装Tensorflow。这里我推荐用Anaconda，方便快捷。首先，在本地下载对应版本的Anaconda，我这里选择的是Python 3.6 version。下载完成后，用FileZilla将其上传至服务器某一目录下，在putty上，cd到该目录，完成安装：1# bash Anaconda3-4.4.0-Linux-x86_64.sh 然后，建立一个Tensorflow的运行环境，并在conda环境中安装Tensorflow：123# conda create -n tensorflow python=3.5# source activate tensorflow# pip install --ignore-installed --upgrade https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.12.1-cp35-cp35m-linux_x86_64.whl 最后，测试安装是否成功：123456# python&gt;&gt;&gt; import tensorflow as tf&gt;&gt;&gt; hello=tf.constant('hello world')&gt;&gt;&gt; sess=tf.Session()&gt;&gt;&gt; print (sess.run(hello))&gt;&gt;&gt; exit() 退出Tensorflow环境1# source deactivate 安装Flask+Nginx+Gunicorn首先安装Flask：12# source activate tensorflow# pip install flask 然后我们测试下Flask是否安装成功。我们在本地创建个hello.py：1234567891011from flask import Flaskapp = Flask(__name__)app.debug=True@app.route('/')def hello_world(): return 'Hello World!'if __name__ == '__main__': app.run(host='0.0.0.0',port=5000) 将此文件上传至服务器 /home/mondon/www/my_flask中（你可以自定义），在putty上cd到此目录下，运行此文件：1# python hello.py 这时，你在本地打开浏览器，输入你的公网IP和端口号（我是101.200.59.7:5000），会看到网页上显示如下，表明Flask安装成功。按Ctrl+C退出运行hello.py。 我们知道 Flask 中自带了 web server，通过 Werkzeug，我们可以搭建 WSGI 服务，运行我们的网站，但 Flask 是 Web 框架，并不是 Web 服务器，尽管 Werkzeug 很强大，但只能用于开发，不能用于生产。 -knarfeh 生产环境中，通常采用Gunicorn/uWSGI+Nginx的组合作为web服务器，因为我没有什么web开发经历，对此了解也不深，就先跟着老司机走了。下面安装Nginx：1# yum install nginx 修改Nginx默认配置，我的Nginx配置文件在 /etc/nginx/nginx.conf，修改nginx.conf中的如下位置的内容：1234567891011121314server &#123; listen 80 default_server; listen [::]:80 default_server; server_name 101.200.59.7; #你的公网IP root /usr/share/nginx/html; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / &#123; proxy_pass http://127.0.0.1:8000; # 这里是指向gunicorn host的服务地址，后面会讲。 proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; 然后运行Nginx：1# nginx 这时还是在本地浏览器输入你的公网IP，会有如下显示，Nginx配置完成：关闭nginx：1# nginx -s stop 我们再来安装Gunicorn：1# pip install gunicorn 好了，所有的配置已经完成，接下来就是如何启动我们的项目了。我们先cd到hello.py所在的目录下，然后依次启动Nginx、Gunicorn，我们的hello.py项目就启动了！（注意，这里127.0.0.1:8000 与上面nginx配置要一致）12# nginx# nohup gunicorn -b 127.0.0.1:8000 hello:app &amp; 访问公网IP来验证下： Tensorflow项目的部署既然”hello world”项目都已经实现了，Tensorflow项目也是如出一辙了。先来看下我项目的截图吧，Web前端设计来自undersail，很漂亮！在本地，我已经将模型训练好了，因此，我们只要把模型和代码一并上传。然后在启动文件中（类似于上面的hello.py），先初始化并加载模型，然后开始监听端口。有post请求时，将接收到的’msg’信息feed到我们的seq2seq模型，就可以得到对答机器人的回答了。在后面的blog中，我将介绍下这个对答机器人是如何实现的，敬请期待~]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Flask</tag>
        <tag>Tensorflow</tag>
        <tag>vps</tag>
        <tag>Nginx</tag>
        <tag>Gunicorn</tag>
      </tags>
  </entry>
</search>
